#!/usr/bin/env python3
# PYTHON_ARGCOMPLETE_OK

import os
import sys
import subprocess as sp

try:
    # import cv2 # sudo pip3 install python-opencv
    import click
    from argparse import ArgumentParser
    from argcomplete import autocomplete
except:
    err = """
    You haven't installed the required dependencies.
    """
    print(err)
    sys.exit(0)

'''
run it as:
    vid-cutter --trim inp.mp4 -s 0:30 -e 1:40
    vid-cutter --trim inp.mp4 -s 0:30 -e 1:40 -o output.mp4

for audio, please specify output name using -o and extension should be mp3
    vid-cutter --crop inp.mp4 -s 0:30 -e 1:40 -o output.mp3
'''



def is_int(x):
    try:
        x = int(x)
    except:
        return False
    return True


def is_valid_file(parser, arg):
    if not os.path.exists(arg):
        parser.error("The file %s does not exist!" % arg)
    else:
        # return open(arg, 'r')  # return an open file handle
        return arg

def validate_crop_args(parser):
    return

def get_time(st):
    st = st.split(':')
    if(len(st) == 1):
        return None
    if(len(st) == 2):
        h='00'
        m,s = st
    if(len(st)==3):
        h,m,s = st
    if(len(st)>3):
        return None

    if(not is_int(h) or not is_int(m)):
        return None
    h = int(h)
    m = int(m)
    s = int(s)
    if(m>59 or s>59):
        return None
    return str(h).zfill(2) + ':' + str(m).zfill(2) + ':' + str(s).zfill(2)

def get_relative(st,et):
    st = st.split(':')
    sh,sm,ss = st

    et = t.split(':')
    eh,em,es = et

    sh = int(sh)
    sm = int(sm)
    ss = int(ss)

    eh = int(eh)
    em = int(em)
    es = int(es)

    if(es < ss):
        if(em == 0):
            if(eh == 0): return None
            eh -= 1
            em += 60
        em -= 1
        es +=60
    s = es - ss

    if(em < sm):
        if(eh == 0):return None
        eh -= 1
        em += 60
    m = em - sm

    if(eh < sh): return None
    h = eh - sh

    if(h == 0 and m == 0 and s == 0): return None
    return str(h).zfill(2) + ':' + str(m).zfill(2) + ':' + str(s).zfill(2)

def getLength(filename):
    result = sp.Popen(["ffprobe", filename],
        stdout = sp.PIPE, stderr = sp.STDOUT)
    arr = [x for x in result.stdout.readlines() if "Duration".encode('utf-8') in x]
    x = arr[0].decode('utf-8')
    x = x.split(' ')
    dur = x.index('Duration:') + 1
    return x[dur].split('.')[0]


def video_trimmer(inp,trimmer,out):
    video_codec = " -c:v copy "
    audio_codec =  " -c:a copy "
    exec_command = 'ffmpeg -i ' + str(inp) + trimmer + video_codec + audio_codec + out
    click.secho(exec_command,fg='green')
    os.system(exec_command)

def video_cropper(inp,trimmer,out):
    video_codec = "" # senseless to say 'copy video and crop both at same time'
    audio_codec =  " -c:a copy "
    exec_command = 'ffmpeg -i ' + str(inp) + filters + video_codec + audio_codec + out
    click.secho(exec_command,fg='green')
    os.system(exec_command)

def audio_cutter(inp,trimmer,out):
    exec_command = 'ffmpeg -i ' + str(inp) + trimmer + codec + out
    click.secho(exec_command,fg='green')
    os.system(exec_command)


def get_filters(parser):
    filters = " "
    if(not parser.crop):
        return filters

    crop_args = {}
    crop_args['crop'] = parser.crop
    crop_args['width'] = str(parser.width/100)
    crop_args['height'] = str(parser.height/100)
    crop_args['x_point'] = str(parser.x_point/100)
    crop_args['y_point'] = str(parser.y_point/100)

    validate_crop_args(crop_args)
    # vid = cv2.VideoCapture(inp)
    # success, frame = vid.read()
    # cv2.imshow('frame',frame)

    # command to crop lower right quatar
    # ffmpeg -i in.mp4 -filter:v "crop=in_w/2:in_h/2:in_w/2:in_h/2" -c:a copy out.mp4
    filters = ' -filter:v "crop=in_w*'+crop_args['width']+':in_h*'+crop_args['height']+ \
        ':in_w*'+crop_args['x_point']+':in_h*'+crop_args['y_point']+'" '

    return filters

def get_io(parser):
    if(not parser.inp):
        inp = input('Please enter input video file path : ')
        if(not os.path.exists(inp)):
            click.secho('File doesnot exist',fg='red')
            sys.exit(0)
    else:
        inp = parser.inp

    if(not parser.output):
        out = ''.join(inp.split('.')[:-1]) + '_output.' + inp.split('.')[-1]
    else:
        out = parser.output

    if(os.path.exists(out)):
        click.secho('[Warning] '+out+' file already exists',fg='yellow')
    return inp,out

def get_trimmer(parser):
    trimmer = ' '
    if(not parser.trim):
        return trimmer

    if(not parser.start_time):
        st = input('Please enter start time in format hh:mm:ss or mm:ss : ')
    else:
        st = parser.start_time
    st = get_time(st)
    if(not st):
        click.secho('Wrong format for start-time',fg='red')
        sys.exit(0)

    if(not parser.time and not parser.end_time):
        t = input('Please enter time duration in format hh:mm:ss or mm:ss : ')
    elif(not parser.time):
        t = parser.end_time
        t = get_time(t)
        if(not t):
            click.secho('Wrong format for end_time',fg='red')
            sys.exit(0)
        t = get_relative(st,t)
        if(not t):
            click.secho('end_time should be greater than start_time',fg='red')
            sys.exit(0)
    else:
        t = parser.time

    t = get_time(t)
    if(not t):
        click.secho('Wrong format for time duration',fg='red')
        sys.exit(0)

    trimmer = " -ss " +str(st)+ " -t " +str(t)
    return trimmer

def get_parser():
    parser = ArgumentParser()
    parser.add_argument("inp",nargs='?',
                        type=lambda x: is_valid_file(parser,x),
                        help="input video file ex: input.mp4")
    parser.add_argument("-o", "--output",help="output file name, ex: output.mp4")

    parser.add_argument("--trim",action="store_true",default=False,help="trim video lenght")
    parser.add_argument("-s", "--start_time", help="start time for cuting in format hh:mm:ss or mm:ss")
    group = parser.add_mutually_exclusive_group()
    group.add_argument("-e", "--end_time", help="end time for cuting in format hh:mm:ss or mm:ss")
    group.add_argument("-t", "--time", help="clip duration in format hh:mm:ss or mm:ss")

    parser.add_argument("--crop",action="store_true",default=False,help="crop video window")
    parser.add_argument("-w", "--width",type=int,default=100,help="crop video window width (on scale of 100)")
    parser.add_argument("-l", "--height",type=int,default=100,help="crop video window height (on scale of 100)")
    parser.add_argument("-x", "--x_point",type=int,default=0,help="crop video window top-left points x (on scale of 100)")
    parser.add_argument("-y", "--y_point",type=int,default=0,help="crop video window top-left points y (on scale of 100)")

    autocomplete(parser)
    parser = parser.parse_args()
    return parser

def verify_dependencies()
    try:
        sp.call(['ffmpeg','--help'],stdout=sp.PIPE,stderr=sp.STDOUT)
    except:
        click.secho('Please install ffmpeg',fg='red')
        sys.exit(0)

if(__name__=="__main__"):
    verify_dependencies()

    parser = get_parser()

    inp,out = get_io(parser)
    trimmer = get_trimmer(parser)
    filters = get_filters(parser)

    # Game starts here
    # print(getLength(inp))
    if(out.split('.')[-1] == 'mp3'):
        audio_cutter(inp,trimmer,out)
    else:
        if(parser.trim):
            video_trimmer(inp,trimmer,out)
        elif(parser.crop):
            video_cropper(inp,filters,out)
